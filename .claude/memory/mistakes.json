{
  "$schema": "Error prevention database - tracks mistakes and technical debt observations",
  "version": "1.2.0",
  "last_updated": "2025-01-05T00:00:00Z",
  "entries": [
    {
      "id": "ERR-001",
      "timestamp": "2025-01-05T00:00:00Z",
      "category": "convention",
      "severity": "medium",
      "trigger": "Using 'any' type in TypeScript",
      "symptom": "Type safety bypassed, runtime errors possible",
      "root_cause": "Avoiding proper typing for speed",
      "resolution": "Define proper types or use 'unknown' with type guards",
      "prevention_rule": "Before using 'any', ask: Can I use 'unknown' with a type guard instead?",
      "affected_files": [],
      "tags": ["typescript", "type-safety", "common"]
    },
    {
      "id": "ERR-002",
      "timestamp": "2025-01-05T00:00:00Z",
      "category": "logic",
      "severity": "high",
      "trigger": "Missing useEffect cleanup function",
      "symptom": "Memory leaks, stale state updates, console warnings about unmounted components",
      "root_cause": "Not cleaning up subscriptions, timers, or event listeners",
      "resolution": "Return a cleanup function from useEffect",
      "prevention_rule": "Every useEffect with subscriptions, timers, or event listeners MUST return a cleanup function",
      "affected_files": [],
      "tags": ["react", "hooks", "memory-leak", "common"]
    },
    {
      "id": "ERR-003",
      "timestamp": "2025-01-05T00:00:00Z",
      "category": "performance",
      "severity": "medium",
      "trigger": "Using array index as React key",
      "symptom": "Incorrect rendering, state bugs when list items are reordered or deleted",
      "root_cause": "React can't track items properly with unstable keys",
      "resolution": "Use stable, unique identifiers (id, uuid) as keys",
      "prevention_rule": "Never use array index as key in dynamic lists. Use item.id or generate stable unique identifiers",
      "affected_files": [],
      "tags": ["react", "performance", "rendering", "common"]
    },
    {
      "id": "ERR-004",
      "timestamp": "2025-01-05T00:00:00Z",
      "category": "logic",
      "severity": "high",
      "trigger": "Direct state mutation",
      "symptom": "Component doesn't re-render, stale UI, unpredictable behavior",
      "root_cause": "Mutating state object/array instead of creating new reference",
      "resolution": "Use setState with new object/array using spread operator or immer",
      "prevention_rule": "Always create new references: setState({...state, key: value}) or setState([...array, newItem])",
      "affected_files": [],
      "tags": ["react", "state", "immutability", "common"]
    },
    {
      "id": "ERR-005",
      "timestamp": "2025-01-05T00:00:00Z",
      "category": "security",
      "severity": "critical",
      "trigger": "Hardcoded secrets or API keys",
      "symptom": "Credentials exposed in source code, security vulnerability",
      "root_cause": "Convenience over security, forgetting to use environment variables",
      "resolution": "Move all sensitive values to environment variables",
      "prevention_rule": "NEVER hardcode secrets. Use process.env or import.meta.env for all API keys, tokens, and credentials",
      "affected_files": [],
      "tags": ["security", "credentials", "env-vars", "critical"]
    },
    {
      "id": "ERR-006",
      "timestamp": "2025-01-05T00:00:00Z",
      "category": "logic",
      "severity": "high",
      "trigger": "Missing error handling for Supabase queries",
      "symptom": "Silent failures, undefined data access, cryptic errors",
      "root_cause": "Not checking the error object returned by Supabase",
      "resolution": "Always destructure {data, error} and handle error case",
      "prevention_rule": "Every Supabase query must check: if (error) { handle it }. Never assume data exists",
      "affected_files": [],
      "tags": ["supabase", "error-handling", "database", "common"]
    },
    {
      "id": "ERR-007",
      "timestamp": "2025-01-05T00:00:00Z",
      "category": "convention",
      "severity": "low",
      "trigger": "Implicit any in event handlers",
      "symptom": "TypeScript errors or loss of type safety in event handling",
      "root_cause": "Not typing event parameter in callbacks",
      "resolution": "Use proper event types: React.MouseEvent<HTMLButtonElement>, React.ChangeEvent<HTMLInputElement>",
      "prevention_rule": "Always type event handlers: (e: React.ChangeEvent<HTMLInputElement>) => void",
      "affected_files": [],
      "tags": ["typescript", "react", "events", "common"]
    },
    {
      "id": "ERR-008",
      "timestamp": "2025-01-05T00:00:00Z",
      "category": "logic",
      "severity": "medium",
      "trigger": "Missing dependency array in useEffect",
      "symptom": "Effect runs on every render or never re-runs when it should",
      "root_cause": "Forgetting dependency array or not including all dependencies",
      "resolution": "Add dependency array with all values used inside the effect",
      "prevention_rule": "Every useEffect needs a dependency array. Include all referenced values. Use ESLint exhaustive-deps rule",
      "affected_files": [],
      "tags": ["react", "hooks", "useEffect", "common"]
    },
    {
      "id": "ERR-009",
      "timestamp": "2025-01-05T00:00:00Z",
      "category": "logic",
      "severity": "medium",
      "trigger": "Async function in useEffect without proper handling",
      "symptom": "Race conditions, state updates after unmount",
      "root_cause": "Directly making async calls without cancellation logic",
      "resolution": "Use AbortController or boolean flag to prevent state updates after unmount",
      "prevention_rule": "For async useEffect: use AbortController or let isMounted = true pattern with cleanup",
      "affected_files": [],
      "tags": ["react", "async", "hooks", "race-condition"]
    },
    {
      "id": "ERR-010",
      "timestamp": "2025-01-05T00:00:00Z",
      "category": "architecture",
      "severity": "medium",
      "trigger": "Prop drilling through many component levels",
      "symptom": "Complex component trees, hard to maintain, excessive re-renders",
      "root_cause": "Passing props through 3+ component levels",
      "resolution": "Use React Context, Zustand, or component composition",
      "prevention_rule": "If passing props through 3+ levels, consider Context or state management. Refactor before it grows",
      "affected_files": [],
      "tags": ["react", "architecture", "state-management", "refactoring"]
    }
  ],
  "debt_observations": [],
  "inherited_issues": []
}
